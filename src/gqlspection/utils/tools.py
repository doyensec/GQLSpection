# coding: utf-8
# These functions are generated by ChatGPT (https://chat.openai.com/chat), Dec 15 [2022] Version.
# According to ChatGPT, the code is licensed under MIT license.

from __future__ import unicode_literals
import json
from gqlspection import log
from gqlspection.six import text_type
from gqlspection.introspection_query import get_introspection_query


def format_comment(string, max_length=80):
    """Format a comment to be no longer than max_length characters per line."""

    # Split the string into lines
    lines = string.split('\n')

    # Initialize a list to store the formatted lines
    formatted_lines = []

    # Iterate through the lines
    for line in lines:
        # Split the line into words
        words = line.split()

        # Initialize a variable to keep track of the current line
        current_line = ''

        # Iterate through the words
        for word in words:
            # If the current line plus the next word would be too long,
            # append the current line to the list of formatted lines and start a new line
            if len(current_line) + len(word) > max_length:
                formatted_lines.append(current_line)
                current_line = ''

            # If the current line is empty, add the word to the line
            # Otherwise, add a space and the word to the line
            if current_line == '':
                current_line = word
            else:
                current_line += ' ' + word

        # Add the remaining line to the list of formatted lines
        formatted_lines.append(current_line)

    # Return the formatted comment
    return '\n'.join(['# ' + line for line in formatted_lines])


def safe_get_list(dictionary, name):
    """Safely extract list from the dictionary, even if the key does not exist or type is wrong."""
    res = dictionary.get(name, [])

    if type(res) is list:
        return res
    else:
        return []


def pad_string(string, n=4):
    """Pad a multiline string with n spaces."""
    if not n or not string:
        return string

    if type(string) == text_type:
        ends_with_newline = string[-1] == '\n'
        return '\n'.join((
            (' ' * n + line) for line in string.splitlines()
        )) + ('\n' if ends_with_newline else '')
    else:
        log.debug("Asked to pad the following non-string with %s spaces: %s", n, string)
        raise Exception("Expected a string to pad, received %s", type(string))


def query_introspection_version(url, headers=None, version='draft', include_metadata=False, request_fn=None):
    """
    Send introspection query with the specified version and get the GraphQL schema.
    """
    log.debug("Introspection query about to be sent with version '%s' to '%s'.", version, url)

    # Get the introspection query
    body = json.dumps({'query': get_introspection_query(version=version)})
    log.debug("Acquired introspection query body")

    # Use requests library by default, but allow overriding
    if not request_fn:
        from requests import request as request_fn

    # Use application/json by default, but allow overriding
    if not headers:
        headers = {'Content-Type': 'application/json'}

    # Send HTTP request
    response = request_fn('POST', url, headers=headers, data=body)
    log.debug("Sent the request and got the response")

    try:
        schema = response.json()
        log.debug("successfully parsed JSON")
    except Exception:
        # TODO: Doesn't this mean it's not a GraphQL endpoint? Maybe early return?
        log.info("Could not parse introspection query for the url '%s' (version: %s).", url, version)
        raise Exception("Could not parse introspection query for the url '%s' (version: %s)." % (url, version))

    if 'errors' in schema:
        for msg in schema['errors']:
            log.info("Received an error from %s (version: %s): %s", url, version, msg)
        return None

    # Catch 4** and 5** errors
    if response.status_code >= 400:
        log.info("Could not query schema from %s (version: %s).", url, version)
        return None

    # Got successful introspection response!
    log.info("Found the introspection response with '%s' version schema.", version)
    log.debug("The received introspection schema: %s", schema)

    if include_metadata:
        schema['__metadata__'] = {'spec_level': version}
        log.debug("Added metadata to introspection schema: %s", schema['__metadata__'])

    return schema


def query_introspection(url, headers=None, include_metadata=False, request_fn=None):
    """
    Send introspection query and get the GraphQL schema with the highest supported spec level.
    """
    log.debug("Introspection query about to be sent to '%s'.", url)

    for version in ('draft', 'oct2021', 'jun2018'):
        schema = query_introspection_version(url, headers=headers, version=version, include_metadata=include_metadata,
                                             request_fn=request_fn)
        if schema:
            return schema
        else:
            log.debug("Introspection query with '%s' version failed: %s", version, schema)

    # None of the introspection queries were successful
    log.warning("Introspection seems disabled for this endpoint: '%s'.", url)
    raise Exception("Introspection seems disabled for this endpoint: '%s'." % url)


def cache_str_repr(cls):
    """A class decorator that caches the __str__ and __repr__ methods."""

    def cached_method(method_func, cache_attribute):
        """Inner decorator to apply caching to a method."""
        def wrapper(self):
            cache_value = getattr(self, cache_attribute, None)
            if cache_value is None:
                cache_value = method_func(self)
                setattr(self, cache_attribute, cache_value)
            return cache_value
        return wrapper

    # Apply caching to the __str__ and __repr__ methods
    cls.__str__ = cached_method(cls.__str__, "__cachedstrings__str__")
    cls.__repr__ = cached_method(cls.__repr__, "__cachedstrings__repr__")

    return cls
